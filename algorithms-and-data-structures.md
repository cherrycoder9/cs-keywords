# Algorithms and data structures

## 알고리즘 (Algorithm)

- 문제 해결을 위한 명확하고 유한한 절차.
- 입력을 받아 원하는 출력을 생성하는 단계적 명령어 집합.

## 시간 복잡도 (Time Complexity)

- 알고리즘 실행 시간과 입력 크기 간의 관계를 나타내는 척도.
- 알고리즘 성능 평가와 비교의 기준.

## 공간 복잡도 (Space Complexity)

- 알고리즘 실행에 필요한 메모리 양과 입력 크기 간의 관계를 나타내는 척도.
- 메모리 사용량 최적화에 중요한 고려 사항.

## 점근적 표기법 (Asymptotic Notation)

- 알고리즘의 시간 및 공간 복잡도를 수학적으로 표현하는 표기법.
- 입력 크기에 따른 성능의 증가 양상을 간결하게 나타냄.

## 자료구조 (Data Structure)

- 데이터의 효율적인 저장, 조직, 관리를 위한 방법론.
- 알고리즘의 성능과 메모리 사용량에 직접적인 영향.

## 배열 (Array)

- 동일한 타입 데이터를 연속된 메모리에 저장하는 기본적인 자료구조.
- 인덱스를 통한 빠른 임의 접근이 가능함.

## 스택 (Stack)

- 가장 최근에 삽입된 데이터를 가장 먼저 제거하는 LIFO 자료구조.
- 함수 호출, 괄호 검사 등에 활용.

## 큐 (Queue)

- 가장 먼저 삽입된 데이터를 가장 먼저 제거하는 FIFO 자료구조.
- 작업 스케줄링, 버퍼 등에 사용.

## 연결 리스트 (Linked List)

- 데이터 요소들이 포인터로 연결된 선형 자료구조.
- 동적 메모리 할당과 삽입/삭제 연산에 유리함.

## 트리 (Tree)

- 계층적 관계를 표현하는 비선형 자료구조.
- 루트 노드에서 시작해 부모-자식 관계로 구성.

## 이진 트리 (Binary Tree)

- 최대 2개의 자식 노드를 가지는 트리 구조.
- 다양한 응용 분야에서 폭넓게 활용됨.

## 이진 탐색 트리 (Binary Search Tree)

- 왼쪽 자식 노드 값 < 부모 노드 값 < 오른쪽 자식 노드 값 특성을 만족하는 이진 트리.
- 효율적인 탐색과 정렬에 사용.

## AVL 트리 (AVL Tree)

- 이진 탐색 트리의 일종으로, 삽입 및 삭제 시 스스로 균형을 유지함.
- 트리의 높이 차이를 최소화하여 검색, 삽입, 삭제 연산을 O(log n) 시간에 수행함.

## 레드-블랙 트리 (Red-Black Tree)

- 자가 균형 이진 탐색 트리로, 노드에 색상 속성을 부여하여 균형을 유지함.
- AVL 트리에 비해 엄격한 균형 조건을 완화하여 연산의 효율성을 높임.

## 그래프 (Graph)

- 정점(vertex)과 간선(edge)으로 이루어진 자료 구조로, 객체 간의 관계를 표현함.
- 경로 탐색, 최단 경로 알고리즘, 위상 정렬 등 다양한 문제 해결에 활용됨.

## 해시 테이블 (Hash Table)

- 키(key)를 해시 함수를 통해 버킷(bucket)이나 슬롯(slot)의 인덱스로 매핑하는 자료 구조.
- 평균 O(1) 시간 복잡도로 빠른 데이터 접근이 가능하며, 키-값 쌍을 저장하는데 효과적임.

## 버블 정렬 (Bubble Sort)

- 인접한 두 원소를 반복적으로 비교하고 교환하여 리스트를 정렬하는 알고리즘.
- 구현이 간단하지만 O(n^2)의 시간 복잡도로 인해 대용량 데이터에는 비효율적임.

## 선택 정렬 (Selection Sort)

- 리스트에서 최솟값을 찾아 맨 앞으로 이동시키는 과정을 반복하는 정렬 알고리즘.
- 버블 정렬과 마찬가지로 O(n^2)의 시간 복잡도를 가지며, 작은 데이터 셋에 적합함.

## 삽입 정렬 (Insertion Sort)

- 정렬된 부분 리스트에 새로운 원소를 적절한 위치에 삽입하며 정렬하는 알고리즘.
- 최선의 경우 O(n), 최악의 경우 O(n^2)의 시간 복잡도를 가지며, 대부분 정렬된 데이터에 효과적임.

## 합병 정렬 (Merge Sort)

- 분할 정복 알고리즘의 일종으로, 리스트를 반으로 나누어 정렬 후 합치는 과정을 반복함.
- 안정 정렬 알고리즘이며, 시간 복잡도는 O(n log n)으로 효율적임.

## 퀵 정렬 (Quick Sort)

- 분할 정복 알고리즘의 일종으로, 피벗(pivot)을 기준으로 리스트를 분할하고 재귀적으로 정렬함.
- 평균적으로 O(n log n)의 시간 복잡도를 가지나, 최악의 경우 O(n^2)이 될 수 있음.

## 기수 정렬 (Radix Sort)

- 비교 연산을 사용하지 않고 데이터를 자릿수 별로 정렬하는 알고리즘.
- 시간 복잡도는 O(d * (n + k))로, 자릿수(d)와 기수(k)에 비례하여 선형 시간에 동작함.

## 힙 정렬 (Heap Sort)

- 최대 힙 또는 최소 힙을 이용하여 정렬하는 알고리즘.
- 추가 메모리 없이 O(n log n)의 시간 복잡도로 정렬할 수 있으며, 이진 힙의 특성을 활용함.

## 선형 탐색 (Linear Search)

- 리스트의 처음부터 끝까지 순차적으로 탐색하여 원하는 값을 찾아내는 알고리즘.
- 시간 복잡도는 O(n)으로, 데이터 크기에 비례하여 비효율적일 수 있음.

## 이진 탐색 (Binary Search)

- 정렬된 리스트에서 중간 값과 비교하며 탐색 범위를 반씩 줄여가는 알고리즘.
- 시간 복잡도는 O(log n)으로, 대량의 데이터 탐색에 효과적임.

## 깊이 우선 탐색 (Depth First Search, DFS)

- 그래프의 한 노드에서 시작하여 최대한 깊이 탐색한 후, 더 이상 탐색할 수 없을 때 이전 노드로 백트래킹하는 알고리즘.
- 스택 또는 재귀 함수를 사용하여 구현하며, 그래프의 모든 노드를 방문하는 것이 목적임.

## 너비 우선 탐색 (Breadth First Search, BFS)

- 그래프의 한 노드에서 시작하여 인접한 노드를 먼저 탐색하고, 차례로 더 깊은 노드로 이동하는 알고리즘.
- 큐를 사용하여 구현하며, 최단 경로 문제나 위상 정렬 등에 활용됨.

## 동적 프로그래밍 (Dynamic Programming)

- 복잡한 문제를 여러 개의 하위 문제로 나누어 해결하고, 그 결과를 메모이제이션하여 중복 계산을 피하는 알고리즘 설계 패러다임.
- 최적 부분 구조와 중복 부분 문제 성질을 가지는 문제 해결에 적합함.

## 분할 정복 (Divide and Conquer)

- 문제를 여러 개의 작은 부분 문제로 분할하여 해결한 후, 결과를 병합하여 원래 문제의 해답을 구하는 알고리즘 설계 패러다임.
- 병합 정렬, 퀵 정렬, 이진 탐색 등이 분할 정복 알고리즘의 대표적인 예시임.

## 그리디 알고리즘 (Greedy Algorithm)

- 매 단계에서 국소적으로 최선의 선택을 하여 최종적으로 최적의 해답에 도달하는 알고리즘 설계 기법.
- 최적 부분 구조 성질을 가지는 문제에 적용 가능하며, 일반적으로 최적해를 보장하지는 않음.

## 백트래킹 (Backtracking)

- 모든 가능한 경우의 수를 고려하며, 현재 상태가 문제의 조건을 만족하지 않으면 이전 상태로 돌아가 다른 경우를 탐색하는 알고리즘 설계 기법.
- 제약 충족 문제나 최적화 문제 해결에 활용되며, DFS와 유사한 방식으로 동작함.

## 최단 경로 알고리즘 (Shortest Path Algorithm)

- 가중치 그래프에서 출발점에서 목적지까지의 최단 경로를 찾는 알고리즘.
- 다익스트라, 벨만-포드, A* 등의 알고리즘이 대표적이며, 최적화 문제 해결에 핵심적인 역할을 함.

## 다익스트라 알고리즘 (Dijkstra's Algorithm)

- 단일 출발점에서 다른 모든 정점까지의 최단 경로를 찾는 그리디 알고리즘.
- 음의 가중치가 없는 그래프에서 사용 가능하며, 우선순위 큐를 활용하여 효율성을 높임.

## 벨만-포드 알고리즘 (Bellman-Ford Algorithm)

- 단일 출발점에서 다른 모든 정점까지의 최단 경로를 찾는 알고리즘.
- 음의 가중치를 포함한 그래프에서도 사용 가능하며, 음의 사이클 존재 여부를 판별할 수 있음.

## 최소 신장 트리 (Minimum Spanning Tree, MST)

- 가중치 무방향 그래프에서 모든 정점을 연결하는 간선들 중 가중치의 합이 최소인 부분 그래프.
- 네트워크 설계, 회로 설계, 클러스터링 등 다양한 분야에서 활용되는 중요한 개념.

## 프림 알고리즘 (Prim's Algorithm)

- 시작 정점에서부터 인접한 정점을 하나씩 선택하여 최소 신장 트리를 만드는 알고리즘.
- 그리디 알고리즘의 일종으로, 우선순위 큐를 사용하여 구현할 수 있음.

## 크루스칼 알고리즘 (Kruskal's Algorithm)

- 간선의 가중치를 오름차순으로 정렬하고, 사이클을 형성하지 않는 간선을 선택하여 최소 신장 트리를 만드는 알고리즘.
- 유니온-파인드 자료구조를 활용하여 사이클 형성 여부를 효율적으로 판별함.

## 인덱싱 (Indexing)

- 데이터베이스에서 검색 성능을 향상시키기 위해 테이블의 일부 열에 대한 별도의 자료구조를 생성하는 기술.
- B-트리, 해시 인덱스 등의 인덱스 구조를 사용하여 빠른 데이터 접근을 가능케 함.

## 트라이 (Trie)

- 문자열 검색을 효율적으로 수행하기 위한 트리 형태의 자료구조.
- 문자열의 각 문자를 노드로 표현하고, 공통 접두사를 공유하여 메모리 사용을 최소화함.

## 유니온 파인드 (Union-Find)

- 서로소 집합을 표현하고 관리하는데 사용되는 자료구조.
- 두 원소가 같은 집합에 속하는지 빠르게 판별하고, 두 집합을 합치는 연산을 효율적으로 수행함.

## 힙 (Heap)

- 최대값 또는 최소값을 빠르게 찾기 위해 사용되는 트리 기반의 자료구조.
- 우선순위 큐, 힙 정렬 등에 활용되며, 부모 노드와 자식 노드 간의 대소 관계를 만족함.

## 이진 힙 (Binary Heap)

- 완전 이진 트리 형태로 구현된 힙 자료구조.
- 배열을 사용하여 효율적으로 구현할 수 있으며, 삽입, 삭제, 최대/최소값 찾기 연산의 시간 복잡도는 O(log n)임.

## 피보나치 힙 (Fibonacci Heap)

- 다양한 연산을 지원하는 높은 효율성의 힙 자료구조.
- 합치기 연산이 O(1) 시간에 수행되며, 감소 키 연산과 삭제 연산도 효율적으로 처리 가능함.
