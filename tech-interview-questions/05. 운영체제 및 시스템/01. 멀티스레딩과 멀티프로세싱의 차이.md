# 멀티스레딩과 멀티프로세싱 비교

멀티스레딩과 멀티프로세싱은 병렬 처리를 통해 프로그램의 성능을 향상시키는 두 가지 주요 접근 방식입니다. 각각의 특성을 이해하고 적절히 활용하는 것이 중요합니다.

## 핵심 차이점

| 특징 | 멀티스레딩 | 멀티프로세싱 |
|------|------------|--------------|
| 메모리 공유 | 공유 | 독립 |
| 자원 소비 | 적음 | 많음 |
| 데이터 동기화 | 필요 | 불필요 (IPC 사용) |
| 확장성 | 제한적 (GIL 등) | 높음 |
| 구현 복잡도 | 상대적으로 낮음 | 높음 |
| 오류 격리 | 취약 | 강력 |

## 구현 예시 (Python)

### 멀티스레딩

```python
import threading
import time

def worker(id):
    print(f"Thread {id} starting")
    time.sleep(2)
    print(f"Thread {id} finishing")

threads = []
for i in range(5):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print("All threads completed")
```

### 멀티프로세싱

```python
import multiprocessing
import time

def worker(id):
    print(f"Process {id} starting")
    time.sleep(2)
    print(f"Process {id} finishing")

if __name__ == '__main__':
    processes = []
    for i in range(5):
        p = multiprocessing.Process(target=worker, args=(i,))
        processes.append(p)
        p.start()

    for p in processes:
        p.join()

    print("All processes completed")
```

## 성능 비교

성능은 작업의 특성과 환경에 따라 크게 달라집니다. 일반적인 경향은 다음과 같습니다:

- **I/O 바운드 작업**: 멀티스레딩이 유리
- **CPU 바운드 작업**: 멀티프로세싱이 유리 (특히 Python의 GIL 고려 시)

```python
import time
import threading
import multiprocessing

def cpu_bound(n):
    return sum(i * i for i in range(n))

def io_bound(n):
    time.sleep(n)

def benchmark(func, n, method):
    start = time.time()
    with multiprocessing.Pool() as p:
        p.map(func, [n] * 4)
    end = time.time()
    print(f"{method} took {end - start:.2f} seconds")

# CPU 바운드 작업
n = 10**7
benchmark(cpu_bound, n, "Multiprocessing (CPU-bound)")

# I/O 바운드 작업
n = 1
benchmark(io_bound, n, "Multiprocessing (I/O-bound)")

# 스레딩 버전은 생략 (유사한 구조로 구현)
```

## 디버깅 팁

### 멀티스레딩

- 레이스 컨디션 주의
- `threading.Lock()`을 사용한 동기화
- 데드락 방지를 위한 `threading.RLock()` 고려

### 멀티프로세싱

- 프로세스 간 통신 (IPC) 메커니즘 활용
- 공유 메모리나 큐를 사용한 데이터 교환
- 프로세스 종료 시 자원 정리 확인

## 고급 사용 시나리오

### 멀티스레딩

1. **GUI 애플리케이션**: 사용자 인터페이스 응답성 유지
2. **웹 서버**: 동시 연결 처리
3. **데이터베이스 연결 풀링**: 연결 관리 최적화

### 멀티프로세싱

1. **대규모 데이터 처리**: 데이터 분할 처리
2. **이미지/비디오 처리**: 프레임별 병렬 처리
3. **과학 계산**: 복잡한 수치 연산 분산 처리

## 하이브리드 접근

복잡한 애플리케이션에서는 멀티스레딩과 멀티프로세싱을 결합하여 사용할 수 있습니다.

```python
import multiprocessing
import threading

def thread_worker(data):
    # 스레드 레벨 작업 수행

def process_worker(data_chunk):
    threads = []
    for item in data_chunk:
        t = threading.Thread(target=thread_worker, args=(item,))
        threads.append(t)
        t.start()
    for t in threads:
        t.join()

if __name__ == '__main__':
    data = [1, 2, 3, 4, 5, 6, 7, 8]
    chunk_size = 2
    chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]

    processes = []
    for chunk in chunks:
        p = multiprocessing.Process(target=process_worker, args=(chunk,))
        processes.append(p)
        p.start()

    for p in processes:
        p.join()
```

## 결론

멀티스레딩과 멀티프로세싱은 각각 고유한 장단점을 가지고 있습니다. 작업의 특성, 시스템 환경, 확장성 요구사항 등을 고려하여 적절한 방식을 선택해야 합니다. 때로는 두 방식을 혼합하여 사용하는 것이 최적의 해결책이 될 수 있습니다. 개발자는 이러한 특성을 이해하고, 실제 성능 측정을 통해 최적의 접근 방식을 결정해야 합니다.
