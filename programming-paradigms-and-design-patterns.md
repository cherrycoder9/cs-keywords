# Programming paradigms and design patterns

## 객체 지향 프로그래밍 (Object-Oriented Programming, OOP)

- 객체를 기반으로 프로그램을 구성하는 패러다임.
- 캡슐화, 상속, 다형성 등의 개념을 통해 코드 모듈화와 재사용성 증대.
- 복잡한 시스템 설계에 적합함.

## 함수형 프로그래밍 (Functional Programming)

- 부작용을 피하고 순수 함수를 사용하는 패러다임.
- 함수를 일급 객체로 취급하여 함수의 조합과 합성 강조.
- 코드 간결성과 테스트 용이성 향상.

## 절차적 프로그래밍 (Procedural Programming)

- 순차적인 명령어 실행을 기반으로 하는 패러다임.
- 문제를 작은 단위의 절차로 분해하여 해결.
- 구조화된 프로그래밍에 적합하나 코드 재사용성은 제한적.

## 선언형 프로그래밍 (Declarative Programming)

- '무엇을' 해야 하는지 명시하고 '어떻게' 수행할지는 추상화하는 패러다임.
- 문제 해결 로직과 구현 로직 분리.
- 도메인 중심 접근법 제공.

## 디자인 패턴 (Design Pattern)

- 소프트웨어 개발 시 자주 직면하는 문제에 대한 재사용 가능한 솔루션.
- 설계 품질과 유지보수성 개선에 기여.
- 의사소통 효율화에도 도움.

## SOLID 원칙 (SOLID Principles)

- 유지보수와 확장이 용이한 객체 지향 설계를 위한 5가지 원칙.
- 단일 책임, 개방-폐쇄, 리스코프 치환, 인터페이스 분리, 의존 역전 원칙으로 구성.

## MVC 패턴 (Model-View-Controller)

- 모델, 뷰, 컨트롤러로 애플리케이션을 구조화하는 디자인 패턴.
- 관심사 분리를 통해 코드 모듈화와 유지보수성 향상.
- 복잡한 UI 개발에 적합.

## MVVM 패턴 (Model-View-ViewModel)

- MVC에서 파생된 패턴으로, 뷰모델을 통해 뷰와 모델 분리.
- 양방향 데이터 바인딩과 명령으로 UI 로직과 비즈니스 로직 분리.
- UI 테스트 용이.

## MVP 패턴 (Model-View-Presenter)

- MVC와 유사하나 뷰와 모델 사이의 상호작용을 프레젠터가 담당.
- 뷰와 모델의 완전한 분리 지향.
- 코드 모듈화와 테스트 가능성 증대.

## 싱글톤 패턴 (Singleton Pattern)

- 오직 하나의 클래스 인스턴스만 생성 보장.
- 글로벌 액세스 포인트 제공.
- 상태 공유 및 조정에 활용.

## 팩토리 패턴 (Factory Pattern)

- 객체 생성을 팩토리 클래스로 캡슐화.
- 객체 생성 과정 추상화.
- 의존성 감소 및 결합도 완화.

## 추상 팩토리 패턴 (Abstract Factory Pattern)

- 상호 관련된 객체군 생성을 추상화.
- 구체적 클래스 노출 없이 객체 생성.
- 제품군 간 독립성 보장.

## 옵저버 패턴 (Observer Pattern)

- 객체 상태 변화 시 관찰자에게 자동 통지.
- 일대다 의존성 정의.
- 객체 간 느슨한 결합 지향.

## 전략 패턴 (Strategy Pattern)

- 동일 계열 알고리즘군을 정의하고 상호 교체 가능케 함.
- 알고리즘 독립적 사용.
- 클라이언트 코드 변경 없이 전략 변경.

## 상태 패턴 (State Pattern)

- 객체 내부 상태에 따른 행위 변화 캡슐화.
- 상태별 로직 분리.
- 상태 천이 명확화.

## 어댑터 패턴 (Adapter Pattern)

- 기존 클래스 인터페이스를 다른 인터페이스로 변환.
- 호환되지 않는 클래스 협력 가능케 함.
- 코드 수정 없이 인터페이스 재사용.

## 데코레이터 패턴 (Decorator Pattern)

- 객체에 동적으로 책임 추가.
- 객체 조합을 통한 기능 확장.
- 하위 클래스 사용 최소화.

## 템플릿 메서드 패턴 (Template Method Pattern)

- 알고리즘 틀 정의, 단계별 오버라이딩 허용.
- 알고리즘 골격 보호.
- 공통 로직은 상위 클래스에, 가변 로직은 하위 클래스에 정의.

## 커맨드 패턴 (Command Pattern)

- 요청을 객체로 감싸 매개변수화.
- 요청 대기열 입력, 로깅, 취소 지원.
- 발동자와 수신자 분리.

## 이터레이터 패턴 (Iterator Pattern)

- 컬렉션의 내부 구조에 상관없이 요소를 순회할 수 있는 통일된 인터페이스 제공.
- 컬렉션과 순회 로직 분리로 독립성과 유연성 향상.

## 컴포지트 패턴 (Composite Pattern)

- 단일 객체와 객체 집합을 동일한 방식으로 다룰 수 있도록 트리 구조 구성.
- 클라이언트 코드의 일관성과 단순성 보장.

## 빌더 패턴 (Builder Pattern)

- 복잡한 객체의 생성 과정을 단계별로 나누어 구축하는 생성 패턴.
- 다양한 구성의 객체 생성을 유연하게 지원.

## 브리지 패턴 (Bridge Pattern)

- 추상화와 구현을 분리하여 독립적인 계층 구조로 발전시킬 수 있도록 함.
- 확장성과 유지보수성 개선.

## 플라이웨이트 패턴 (Flyweight Pattern)

- 동일하거나 유사한 객체를 공유하여 메모리 사용량 최소화.
- 대규모 객체 집합을 효율적으로 처리 가능.

## 프로토타입 패턴 (Prototype Pattern)

- 기존 객체를 복사하여 새로운 객체 생성.
- 복잡한 객체의 초기화 과정 단순화 및 성능 향상.

## 메멘토 패턴 (Memento Pattern)

- 객체의 상태를 저장하고 이전 상태로 복원할 수 있게 함.
- 캡슐화를 유지하면서 스냅샷 기능 제공.

## 방문자 패턴 (Visitor Pattern)

- 객체 구조와 연산을 분리하여 새로운 연산 추가를 용이하게 함.
- 객체 구조 변경 없이 기능 확장 가능.

## 중재자 패턴 (Mediator Pattern)

- 객체 간 상호작용을 중앙집중화하여 객체 간 느슨한 결합 유도.
- 객체 간 통신의 복잡성 감소.

## 책임 연쇄 패턴 (Chain of Responsibility Pattern)

- 요청을 일련의 객체 체인에서 처리할 수 있도록 함.
- 유연한 요청 처리와 결합도 감소.

## 인터프리터 패턴 (Interpreter Pattern)

- 언어의 문법을 표현하는 방식으로 구조화하여 해석기 역할을 하는 객체 생성.
- 도메인 특화 언어 구현에 적합.

## 퍼사드 패턴 (Facade Pattern)

- 복잡한 서브시스템의 인터페이스를 단순화된 하이레벨 인터페이스로 제공.
- 서브시스템 의존성을 최소화하고 사용 편의성 향상.

## 프록시 패턴 (Proxy Pattern)

- 실제 객체에 대한 접근을 제어하는 대리자 객체 사용.
- 접근 제한, 지연 초기화, 부가 기능 추가 등에 활용.
