# Programming paradigms and design patterns

## 객체 지향 프로그래밍 (Object-Oriented Programming, OOP)

- 데이터와 그 데이터를 조작하는 메서드를 하나의 객체로 캡슐화하는 프로그래밍 패러다임
- 상속, 다형성, 캡슐화, 추상화 등의 개념을 통해 코드의 재사용성과 유지보수성을 높임

## 함수형 프로그래밍 (Functional Programming)

- 순수 함수를 조합하여 소프트웨어를 만드는 프로그래밍 패러다임
- 불변성과 부수 효과의 최소화를 통해 예측 가능하고 테스트하기 쉬운 코드를 작성함

## 절차적 프로그래밍 (Procedural Programming)

- 프로그램의 로직을 순차적인 함수 호출로 구성하는 프로그래밍 패러다임
- 코드의 재사용을 위해 모듈화를 강조하며, 구조화된 프로그래밍의 기초가 됨

## 선언적 프로그래밍 (Declarative Programming)

- 프로그램의 로직을 어떻게(How) 수행할지가 아닌 무엇(What)을 수행할지 설명하는 방식의 프로그래밍
- SQL, HTML 등이 대표적이며, 복잡한 알고리즘을 추상화하여 간결하게 표현할 수 있음

## 디자인 패턴 (Design Pattern)

- 소프트웨어 설계에서 자주 발생하는 문제에 대한 검증된 해결책
- 재사용 가능한 설계 방식을 제공하여 개발 효율성을 높이고 유지보수성을 개선함

## SOLID 원칙

- 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙을 마이클 페더스가 소개한 약어
- 단일 책임 원칙, 개방-폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존관계 역전 원칙
- 유지보수와 확장이 용이한 시스템을 설계하는 데 도움을 줌

## MVC 패턴 (Model-View-Controller)

- 애플리케이션 구조를 모델, 뷰, 컨트롤러로 분리하는 디자인 패턴
- 각 요소의 독립성을 높여 유지보수성과 확장성을 개선함

## MVVM 패턴 (Model-View-ViewModel)

- MVC의 확장형으로, 뷰와 모델 사이에 뷰모델을 두어 결합도를 낮춤
- 데이터 바인딩을 활용해 뷰와 로직의 분리를 강화하고 테스트 용이성을 높임

## MVP 패턴 (Model-View-Presenter)

- 프레젠터를 통해 뷰와 모델의 상호작용을 관리하는 패턴
- 뷰의 수동성을 강조하여 테스트 용이성과 모듈성을 향상시킴

## 싱글톤 패턴 (Singleton Pattern)

- 클래스의 인스턴스를 오직 하나만 생성하고 전역적으로 접근할 수 있게 하는 패턴
- 리소스 공유와 전역 상태 관리에 유용하나, 과도한 사용은 결합도를 높일 수 있음

## 팩토리 패턴 (Factory Pattern)

- 객체 생성 로직을 별도의 클래스/메서드로 분리하는 생성 패턴
- 객체 생성의 유연성을 높이고 코드 재사용성을 향상시킴

## 추상 팩토리 패턴 (Abstract Factory Pattern)

- 관련된 객체들의 집합을 생성하는 인터페이스를 제공하는 생성 패턴
- 구체적인 클래스에 의존하지 않고 관련 객체군을 생성할 수 있게 함

## 옵저버 패턴 (Observer Pattern)

- 객체 간 일대다 의존 관계를 정의하여 상태 변화를 통지하는 행위 패턴
- 느슨한 결합을 유지하면서 객체 간 상태 동기화를 가능하게 함

## 전략 패턴 (Strategy Pattern)

- 알고리즘군을 정의하고 각각을 캡슐화하여 교체 가능하게 만드는 행위 패턴
- 런타임에 알고리즘을 선택할 수 있게 하여 유연성을 높임

## 상태 패턴 (State Pattern)

- 객체의 내부 상태에 따라 행동을 변경할 수 있게 하는 행위 패턴
- 복잡한 조건문을 피하고 상태 전이를 명확하게 표현할 수 있게 함

## 어댑터 패턴 (Adapter Pattern)

- 호환되지 않는 인터페이스를 가진 객체들이 협력할 수 있게 하는 구조 패턴
- 기존 코드를 변경하지 않고 새로운 인터페이스를 사용할 수 있게 함

## 데코레이터 패턴 (Decorator Pattern)

- 객체에 동적으로 새로운 책임을 추가할 수 있게 하는 구조 패턴
- 상속을 사용하지 않고 기능을 확장할 수 있어 유연성을 높임

## 템플릿 메서드 패턴 (Template Method Pattern)

- 알고리즘의 구조를 정의하고 일부 단계를 서브클래스에서 구현하게 하는 행위 패턴
- 코드 재사용성을 높이면서 알고리즘의 특정 단계를 커스터마이즈할 수 있게 함

## 커맨드 패턴 (Command Pattern)

- 요청을 객체로 캡슐화하여 매개변수화, 큐잉, 로깅 등을 가능하게 하는 행위 패턴
- 요청의 발신자와 수신자를 분리하여 유연성을 높임

## 이터레이터 패턴 (Iterator Pattern)

- 컬렉션의 내부 구조를 노출하지 않고 순차적으로 요소에 접근하는 방법을 제공하는 행위 패턴
- 다양한 컬렉션 구조에 대해 일관된 순회 인터페이스를 제공함

## 컴포지트 패턴 (Composite Pattern)

- 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현하는 구조 패턴
- 개별 객체와 복합 객체를 동일하게 다룰 수 있게 함

## 빌더 패턴 (Builder Pattern)

- 복잡한 객체의 생성 과정과 표현 방법을 분리하는 생성 패턴
- 동일한 생성 과정으로 서로 다른 표현 결과를 만들 수 있음

## 브리지 패턴 (Bridge Pattern)

- 추상화와 구현을 분리하여 독립적으로 변형할 수 있게 하는 구조 패턴
- 계층 구조의 확장성을 높이고 구현 세부사항을 사용자로부터 숨김

## 플라이웨이트 패턴 (Flyweight Pattern)

- 다수의 유사한 객체를 효율적으로 공유하여 메모리 사용을 최적화하는 구조 패턴
- 객체의 내부 상태를 공유하여 사용 가능한 경우에 적용함

## 프로토타입 패턴 (Prototype Pattern)

- 기존 객체를 복제하여 새로운 객체를 생성하는 생성 패턴
- 객체 생성 비용이 높은 경우 효율적인 객체 생성 방법을 제공함

## 메멘토 패턴 (Memento Pattern)

- 객체의 내부 상태를 캡슐화하여 저장하고 복원할 수 있게 하는 행위 패턴
- 객체의 상태 스냅샷을 만들어 이전 상태로 복원할 수 있게 함

## 방문자 패턴 (Visitor Pattern)

- 알고리즘을 객체 구조에서 분리하여 새로운 연산을 추가할 수 있게 하는 행위 패턴
- 객체 구조를 변경하지 않고 새로운 기능을 추가할 수 있음

## 중재자 패턴 (Mediator Pattern)

- 객체 간의 복잡한 상호작용을 캡슐화하여 중앙 집중화하는 행위 패턴
- 객체 간 결합도를 낮추고 유지보수성을 향상시킴

## 책임 연쇄 패턴 (Chain of Responsibility Pattern)

- 요청을 처리할 수 있는 객체를 체인으로 연결하여 요청을 전달하는 행위 패턴
- 요청의 발신자와 수신자를 분리하여 유연성을 높임

## 해석자 패턴 (Interpreter Pattern)

- 언어 문법이나 표현을 평가하는 방법을 정의하는 행위 패턴
- 특정 언어의 문법을 해석하고 처리하는 인터프리터를 구현함

## 퍼사드 패턴 (Facade Pattern)

- 복잡한 서브시스템에 대한 단순화된 인터페이스를 제공하는 구조 패턴
- 클라이언트와 서브시스템 간의 결합도를 낮추고 사용 편의성을 높임

## 프록시 패턴 (Proxy Pattern)

- 다른 객체에 대한 대리자 또는 플레이스홀더를 제공하는 구조 패턴
- 원본 객체에 대한 접근을 제어하거나 추가적인 기능을 제공함
